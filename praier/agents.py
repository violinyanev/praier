"""
Multi-agent system for PR analysis and automation.

This module implements a team of specialized agents that work together
to analyze pull requests and provide targeted insights and actions.
"""

import logging
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from typing import Dict, List, Optional

from .github_client import CheckRun, PullRequest, WorkflowRun

logger = logging.getLogger(__name__)


@dataclass
class AgentReport:
    """Report generated by an agent after analyzing a PR."""

    agent_name: str
    pr_number: int
    repository: str
    summary: str
    findings: List[str] = field(default_factory=list)
    recommendations: List[str] = field(default_factory=list)
    actions_taken: List[str] = field(default_factory=list)
    priority: str = "low"  # low, high, critical


class Agent(ABC):
    """Base class for all agents in the team."""

    def __init__(self, name: str, enabled: bool = True):
        self.name = name
        self.enabled = enabled
        self.logger = logging.getLogger(f"{__name__}.{name}")

    @abstractmethod
    async def analyze(
        self,
        pr: PullRequest,
        repository: str,
        check_runs: List[CheckRun],
        workflow_runs: List[WorkflowRun],
    ) -> AgentReport:
        """Analyze a pull request and generate a report."""
        pass

    def is_enabled(self) -> bool:
        """Check if the agent is enabled."""
        return self.enabled

    def enable(self):
        """Enable the agent."""
        self.enabled = True
        self.logger.info(f"{self.name} agent enabled")

    def disable(self):
        """Disable the agent."""
        self.enabled = False
        self.logger.info(f"{self.name} agent disabled")


class DeveloperAgent(Agent):
    """Agent focused on code quality and development best practices."""

    def __init__(self, enabled: bool = True):
        super().__init__("Developer", enabled)

    async def analyze(
        self,
        pr: PullRequest,
        repository: str,
        check_runs: List[CheckRun],
        workflow_runs: List[WorkflowRun],
    ) -> AgentReport:
        """Analyze PR from a development perspective."""
        self.logger.debug(f"Developer analyzing PR #{pr.number}")

        report = AgentReport(
            agent_name=self.name,
            pr_number=pr.number,
            repository=repository,
            summary="",
            findings=[],
            recommendations=[],
        )

        # Check for failing code quality checks
        code_quality_checks = [
            check
            for check in check_runs
            if check.status == "completed"
            and check.conclusion == "failure"
            and any(
                keyword in check.name.lower()
                for keyword in ["lint", "format", "style", "quality"]
            )
        ]

        if code_quality_checks:
            report.findings.append(
                f"Found {len(code_quality_checks)} failing code quality checks"
            )
            for check in code_quality_checks:
                report.findings.append(f"  - {check.name}: {check.conclusion}")
            report.recommendations.append(
                "Review code quality issues and apply automatic formatters where possible"
            )
            report.priority = "high"

        # Check if PR is in draft mode
        if pr.draft:
            report.findings.append("PR is in draft mode")
            report.recommendations.append(
                "Mark as ready for review when development is complete"
            )

        # Analyze workflow runs
        failing_workflows = [
            run
            for run in workflow_runs
            if run.conclusion == "failure" and pr.number in run.pull_requests
        ]

        if failing_workflows:
            report.findings.append(
                f"Found {len(failing_workflows)} failing workflow runs"
            )
            report.recommendations.append(
                "Investigate workflow failures and fix any build/compilation issues"
            )
            report.priority = "high"

        # Generate summary
        if report.findings:
            report.summary = f"Developer analysis found {len(report.findings)} issues requiring attention"
        else:
            report.summary = (
                "Code appears to be in good shape from development perspective"
            )
            report.priority = "low"

        return report


class TesterAgent(Agent):
    """Agent focused on testing and quality assurance."""

    def __init__(self, enabled: bool = True):
        super().__init__("Tester", enabled)

    async def analyze(
        self,
        pr: PullRequest,
        repository: str,
        check_runs: List[CheckRun],
        workflow_runs: List[WorkflowRun],
    ) -> AgentReport:
        """Analyze PR from a testing perspective."""
        self.logger.debug(f"Tester analyzing PR #{pr.number}")

        report = AgentReport(
            agent_name=self.name,
            pr_number=pr.number,
            repository=repository,
            summary="",
            findings=[],
            recommendations=[],
        )

        # Check for failing test checks
        test_checks = [
            check
            for check in check_runs
            if check.status == "completed"
            and check.conclusion == "failure"
            and any(
                keyword in check.name.lower()
                for keyword in ["test", "pytest", "jest", "spec", "unit", "integration"]
            )
        ]

        if test_checks:
            report.findings.append(f"Found {len(test_checks)} failing test checks")
            for check in test_checks:
                report.findings.append(f"  - {check.name}: {check.conclusion}")
            report.recommendations.append(
                "Review test failures and fix or update tests as needed"
            )
            report.priority = "critical"

        # Check for passing tests
        passing_tests = [
            check
            for check in check_runs
            if check.status == "completed"
            and check.conclusion == "success"
            and any(keyword in check.name.lower() for keyword in ["test"])
        ]

        if passing_tests:
            report.findings.append(
                f"{len(passing_tests)} test checks passed successfully"
            )

        # Generate summary
        if test_checks:
            report.summary = f"Testing identified {len(test_checks)} failing test suites - immediate attention required"
        elif passing_tests:
            report.summary = "All test checks passing - good test coverage"
            report.priority = "low"
        else:
            report.summary = (
                "No test checks detected - consider adding automated testing"
            )
            report.recommendations.append(
                "Add automated tests to ensure code quality and prevent regressions"
            )
            report.priority = "normal"

        return report


class DocumentationAgent(Agent):
    """Agent focused on documentation quality and completeness."""

    def __init__(self, enabled: bool = True):
        super().__init__("Documentation", enabled)

    async def analyze(
        self,
        pr: PullRequest,
        repository: str,
        check_runs: List[CheckRun],
        workflow_runs: List[WorkflowRun],
    ) -> AgentReport:
        """Analyze PR from a documentation perspective."""
        self.logger.debug(f"Documentation agent analyzing PR #{pr.number}")

        report = AgentReport(
            agent_name=self.name,
            pr_number=pr.number,
            repository=repository,
            summary="",
            findings=[],
            recommendations=[],
        )

        # Check for documentation-related checks
        doc_checks = [
            check
            for check in check_runs
            if any(
                keyword in check.name.lower()
                for keyword in ["doc", "documentation", "readme", "sphinx", "mkdocs"]
            )
        ]

        if doc_checks:
            failing_doc_checks = [
                check
                for check in doc_checks
                if check.status == "completed" and check.conclusion == "failure"
            ]

            if failing_doc_checks:
                report.findings.append(
                    f"Found {len(failing_doc_checks)} failing documentation checks"
                )
                for check in failing_doc_checks:
                    report.findings.append(f"  - {check.name}: {check.conclusion}")
                report.recommendations.append(
                    "Fix documentation build errors and ensure all docs are up to date"
                )
                report.priority = "high"

            passing_doc_checks = [
                check
                for check in doc_checks
                if check.status == "completed" and check.conclusion == "success"
            ]

            if passing_doc_checks:
                report.findings.append(
                    f"{len(passing_doc_checks)} documentation checks passed"
                )

        # Check PR title and description
        if not pr.title or len(pr.title) < 10:
            report.findings.append("PR title is too short or missing")
            report.recommendations.append(
                "Provide a clear, descriptive title for the PR"
            )
            report.priority = "normal"

        # Generate summary
        if not doc_checks:
            report.summary = "No documentation checks detected"
            report.recommendations.append(
                "Consider adding documentation validation to your CI pipeline"
            )
            report.priority = "low"
        elif any("failing" in finding for finding in report.findings):
            report.summary = "Documentation issues detected that need attention"
        else:
            report.summary = "Documentation appears to be in good shape"
            report.priority = "low"

        return report


class ProjectManagerAgent(Agent):
    """Agent focused on coordinating work and providing overall insights."""

    def __init__(self, enabled: bool = True):
        super().__init__("ProjectManager", enabled)

    async def analyze(
        self,
        pr: PullRequest,
        repository: str,
        check_runs: List[CheckRun],
        workflow_runs: List[WorkflowRun],
    ) -> AgentReport:
        """Analyze PR from a project management perspective."""
        self.logger.debug(f"Project Manager analyzing PR #{pr.number}")

        report = AgentReport(
            agent_name=self.name,
            pr_number=pr.number,
            repository=repository,
            summary="",
            findings=[],
            recommendations=[],
        )

        # Overall status assessment
        total_checks = len(check_runs)
        completed_checks = [
            check for check in check_runs if check.status == "completed"
        ]
        failing_checks = [
            check
            for check in completed_checks
            if check.conclusion in ["failure", "cancelled", "timed_out"]
        ]
        passing_checks = [
            check for check in completed_checks if check.conclusion == "success"
        ]

        report.findings.append(f"Total checks: {total_checks}")
        report.findings.append(f"Completed: {len(completed_checks)}")
        report.findings.append(f"Passing: {len(passing_checks)}")
        report.findings.append(f"Failing: {len(failing_checks)}")

        # Workflow status
        total_workflows = len(workflow_runs)
        pr_workflows = [run for run in workflow_runs if pr.number in run.pull_requests]

        if pr_workflows:
            report.findings.append(f"Associated workflow runs: {len(pr_workflows)}")

            queued_workflows = [run for run in pr_workflows if run.status == "queued"]
            if queued_workflows:
                report.findings.append(
                    f"{len(queued_workflows)} workflows waiting for approval"
                )
                report.recommendations.append(
                    "Approve pending workflows to continue CI/CD process"
                )

        # Determine priority based on failures
        if failing_checks:
            critical_failures = len(
                [
                    c
                    for c in failing_checks
                    if any(
                        keyword in c.name.lower()
                        for keyword in ["test", "security", "build"]
                    )
                ]
            )
            if critical_failures > 0:
                report.priority = "critical"
                report.recommendations.append(
                    "Address critical test/security/build failures immediately"
                )
            else:
                report.priority = "high"
                report.recommendations.append("Fix failing checks before merging")
        else:
            report.priority = "low"

        # Generate summary
        if failing_checks:
            report.summary = f"PR status: {len(failing_checks)}/{total_checks} checks failing - review required"
        elif len(completed_checks) < total_checks:
            report.summary = f"PR status: {total_checks - len(completed_checks)} checks still running"
        else:
            report.summary = "PR status: All checks passing - ready for review/merge"

        return report


class AgentTeam:
    """Coordinates a team of agents working together on PR analysis."""

    def __init__(self):
        self.agents: List[Agent] = []
        self.logger = logging.getLogger(f"{__name__}.AgentTeam")

    def add_agent(self, agent: Agent):
        """Add an agent to the team."""
        self.agents.append(agent)
        self.logger.info(f"Added {agent.name} agent to team")

    def remove_agent(self, agent_name: str):
        """Remove an agent from the team."""
        self.agents = [agent for agent in self.agents if agent.name != agent_name]
        self.logger.info(f"Removed {agent_name} agent from team")

    def get_agent(self, agent_name: str) -> Optional[Agent]:
        """Get an agent by name."""
        for agent in self.agents:
            if agent.name == agent_name:
                return agent
        return None

    def list_agents(self) -> List[str]:
        """List all agents in the team."""
        return [agent.name for agent in self.agents]

    async def analyze_pr(
        self,
        pr: PullRequest,
        repository: str,
        check_runs: List[CheckRun],
        workflow_runs: List[WorkflowRun],
    ) -> Dict[str, AgentReport]:
        """Run all enabled agents on a PR and collect their reports."""
        self.logger.info(f"Team analyzing PR #{pr.number} in {repository}")

        reports = {}

        for agent in self.agents:
            if not agent.is_enabled():
                self.logger.debug(f"Skipping disabled agent: {agent.name}")
                continue

            try:
                report = await agent.analyze(pr, repository, check_runs, workflow_runs)
                reports[agent.name] = report
                self.logger.debug(f"{agent.name} completed analysis")
            except Exception as e:
                self.logger.error(
                    f"Error in {agent.name} agent analysis: {e}", exc_info=True
                )

        return reports

    def get_team_summary(self, reports: Dict[str, AgentReport]) -> Dict[str, any]:
        """Generate a summary of all agent reports."""
        summary = {
            "total_agents": len(self.agents),
            "active_agents": len(reports),
            "priorities": {},
            "total_findings": 0,
            "total_recommendations": 0,
            "agent_summaries": {},
        }

        for agent_name, report in reports.items():
            summary["priorities"][agent_name] = report.priority
            summary["total_findings"] += len(report.findings)
            summary["total_recommendations"] += len(report.recommendations)
            summary["agent_summaries"][agent_name] = report.summary

        # Determine overall priority
        priority_order = {"critical": 4, "high": 3, "normal": 2, "low": 1}
        highest_priority = max(
            reports.values(),
            key=lambda r: priority_order.get(r.priority, 0),
            default=None,
        )

        if highest_priority:
            summary["overall_priority"] = highest_priority.priority
        else:
            summary["overall_priority"] = "low"

        return summary


def create_default_team() -> AgentTeam:
    """Create a default team with all standard agents."""
    team = AgentTeam()
    team.add_agent(DeveloperAgent())
    team.add_agent(TesterAgent())
    team.add_agent(DocumentationAgent())
    team.add_agent(ProjectManagerAgent())
    return team
